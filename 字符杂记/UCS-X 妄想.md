# UCS-X 超级扩充方案
在阅读 [UCS-X](https://www.ucsx.org/) 后，我有一个大胆的想法。

下面我将会阐述 UCS-X 的扩充技术细节，以及自己模仿扩充。

## 分段称呼
### UCS-M
指普通的、最大到 U+10FFFF 的情形。

### UCS-G
指最大到 U+7FFFFFFF 的情形。

### UCS-E
指最大到 U+7FFFFFFFFFFFFFFF 的情形。

### UCS-∞
指空间无限的情形。

## 编码方式
以下所述的编码方式承接正常编码方式（包含废案）。

原则上对 UTF-8、UTF-16、UTF-32 进行体系扩充，其余编码则由它们进行转换或变形来扩充。

UCS-X 扩充了如下方案：
- UTF-8
- UTF-16
- UTF-32
- GB 系

模仿扩充了如下方案：
- UTF-1
- 屁牌编码
- UTF-EBCDIC 系

### UTF-8
#### U+80000000\~U+FFFFFFFFF
先将 UCS Code Point 存储为五字节。

这时的结构为：
- 0000aaaa
- aabbbbbb
- ccccccdd
- ddddeeee
- eeffffff

将其代入此结构，形成七字节：
- 11111110
- 10aaaaaa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff

拆开来看，就可以这么理解：

先将 UCS Code Point 记作 U。

将 U 除以 68719476736，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=68719476736，也就相当于把二进制的后面 36 位和前面分离了）

将 b₁ 除以 1073741824，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₂ 除以 16777216，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₃ 除以 262144，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₄ 除以 4096，取出商和余数，分别记作 a₅ 和 b₅。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₅ 除以 64，取出商和余数，分别记作 a₆ 和 b₆。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则七个字节分别是：
- a₁+0xFE（即：a₁ 表示是第几次 68719476736 循环，但是 a₁ 在此范围内为 0）
- a₂+0x80（即：a₂ 表示是第几次 1073741824 循环）
- a₃+0x80（即：a₃ 表示是第几次 16777216 循环）
- a₄+0x80（即：a₄ 表示是第几次 262144 循环）
- a₅+0x80（即：a₅ 表示是第几次 4096 循环）
- a₆+0x80（即：a₆ 表示是第几次 64 循环）
- b₆+0x80（即：b₆ 表示 64 循环后的第几个）

由此就得到 U+80000000\~U+FFFFFFFFF 的 UTF-8。

#### U+1000000000\~U+7FFFFFFFFFFFFFFFFF
先将 UCS Code Point 存储为九字节。

这时的结构为：
- 0aaaaabb
- bbbbcccc
- ccdddddd
- eeeeeeff
- ffffgggg
- gghhhhhh
- iiiiiijj
- jjjjkkkk
- kkllllll

将其代入此结构，形成十三字节：
- 11111111
- 100aaaaa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff
- 10gggggg
- 10hhhhhh
- 10iiiiii
- 10jjjjjj
- 10kkkkkk
- 10llllll

拆开来看，就可以这么理解：

先将 UCS Code Point 记作 U。

将 U 除以 2361183241434822606848，取出商和余数，分别记作 a₁ 和 b₁。（即：(0x9F-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=2361183241434822606848，也就相当于把二进制的后面 71 位和前面分离了）

将 b₁ 除以 73786976294838206464，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=73786976294838206464，也就相当于把二进制的后面 66 位和前面分离了）

将 b₂ 除以 1152921504606846976，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1152921504606846976，也就相当于把二进制的后面 60 位和前面分离了）

将 b₃ 除以 18014398509481984，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=18014398509481984，也就相当于把二进制的后面 54 位和前面分离了）

将 b₄ 除以 281474976710656，取出商和余数，分别记作 a₅ 和 b₅。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=281474976710656，也就相当于把二进制的后面 48 位和前面分离了）

将 b₅ 除以 4398046511104，取出商和余数，分别记作 a₆ 和 b₆。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=4398046511104，也就相当于把二进制的后面 42 位和前面分离了）

将 b₆ 除以 68719476736，取出商和余数，分别记作 a₇ 和 b₇。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=68719476736，也就相当于把二进制的后面 36 位和前面分离了）

将 b₇ 除以 1073741824，取出商和余数，分别记作 a₈ 和 b₈。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₈ 除以 16777216，取出商和余数，分别记作 a₉ 和 b₉。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₉ 除以 262144，取出商和余数，分别记作 a₁₀ 和 b₁₀。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₁₀ 除以 4096，取出商和余数，分别记作 a₁₁ 和 b₁₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₁₁ 除以 64，取出商和余数，分别记作 a₁₂ 和 b₁₂。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则十三个字节分别是：
- a₁+0xFF（即：a₁ 表示是第几次 2361183241434822606848 循环，但是 a₁ 在此范围内为 0）
- a₂+0x80（即：a₂ 表示是第几次 73786976294838206464 循环）
- a₃+0x80（即：a₃ 表示是第几次 1152921504606846976 循环）
- a₄+0x80（即：a₄ 表示是第几次 18014398509481984 循环）
- a₅+0x80（即：a₅ 表示是第几次 281474976710656 循环）
- a₆+0x80（即：a₆ 表示是第几次 4398046511104 循环）
- a₇+0x80（即：a₇ 表示是第几次 68719476736 循环）
- a₈+0x80（即：a₈ 表示是第几次 1073741824 循环）
- a₉+0x80（即：a₉ 表示是第几次 16777216 循环）
- a₁₀+0x80（即：a₁₀ 表示是第几次 262144 循环）
- a₁₁+0x80（即：a₁₁ 表示是第几次 4096 循环）
- a₁₂+0x80（即：a₁₂ 表示是第几次 64 循环）
- b₁₂+0x80（即：b₁₂ 表示 64 循环后的第几个）

由此就得到 U+1000000000\~U+7FFFFFFFFFFFFFFFFF 的 UTF-8。

#### U+800000000000000000 及以上
定义 NUD 为 U+ 后面的十六进制数位数，但不包含前面的 0。

定义 NME=NUD-18。

第一字节为 0xFF。

##### 如果 NME 小于等于 15
那么下一个字节为 0xA0+NME。

##### 如果 NME 大于等于 16
后面会是多个 0xB4 跟随多个 0xA* 字节，0xB4 的数量比 0xA* 的数量少 1。

为什么是 0xB4 呢？因为 B4 谐音 Before（之前）。

那么 0xA* 怎么计算呢？

把 NME 表示成十六进制，再把这串的每一位都加上 0xA0，形成多个字节。

例如当 NME=0x125，那么前面几个字节就是：

0xFFB4B4A1A2A5

执行完上面的步骤后，进入下一个环节。

如果 NUD 不是三的倍数，在 UCS 码二进制串前面填充 0，直到位数变成 12 的倍数为止。

事实上就相当于在十六进制下将位数填充为 3 的倍数。

此时便可在二进制下把那 UCS 码点串每六位分割，分割的每个部分前面填充 10，再把处理后的整串填到后面。

下面我们以 U+1000000000000000000000000000000000 为例，进行运算。

容易知道 NUD=34、NME=34-18=16。

所以可以得出前面是 0xFFB4A1A0。

又因为 NUD 不是三的倍数，所以填充 0 变成 0x001000000000000000000000000000000000。

转换成二进制，每六位分割：

000000 000001 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000

补上 10。

10000000 10000001 10000000 10000000 10000000……

所以最终结果是 0xFFB4A1A0808180808080808080808080808080808080808080808080。

### UTF-16
#### U+110000\~U+3FFFFFFFFFFFFFFFFFFFFFF
首先我们要理解扩充方案头单元的作用，从二进制的角度辨析。

本扩充方案会用到代理区。

头单元的基本结构是 1101110xxxxxxxxx，其中 xxxxxxxxx 有什么作用？让我们看这张表。

|头单元低九位的结构|总计单元数|存储 UCS 码的最大位数|
|-|-|-|
|0yyyyyyyy|3|26|
|10yyyyyyy|4|34|
|110yyyyyy|5|42|
|1110yyyyy|6|50|
|11110yyyy|7|58|
|111110yyy|8|66|
|1111110yy|9|74|
|11111110y|10|82|
|111111110|11|90|

UTF-16 一个单元为双字节。

表中 y 表示存储 UCS 码的部分。

随后的单元就只用来存储 UCS 码了。其结构为 1101111xxxxxxxxx，x 表示存储 UCS 码的部分。

存储时当然是越短越好，那么如何存储呢？

首先将 UCS 码从十六进制转换到二进制，同时把前面的 0 去掉。再参照上表选择合适的单元数。

如果位数小于这样的单元能存储的最大位数，就要在前面填充 0，直到足够为止。

下面我们以 U+200000 为例，演示转换过程。

转换成二进制，得 001000000000000000000000。

去除前导 0，得 1000000000000000000000。有 22 位，所以选择三单元方案。

22 小于 26，所以填充并分割为 00001000 000000000 000000000。

代入结构，即是 1101110000001000 1101111000000000 1101111000000000。

所以得到 0xDC08DE00DE00。

#### U+40000000000000000000000 及以上

现在请联系 UTF-8 的扩展方案。

定义 NMT=NUD-23，第一单元为 0xDDFF。

##### 如果 NMT 小于等于 255
下一个单元首先是 0xDE，然后紧接的字节等于 NMT。

如 NMT=5 时，起始的几个单元为 0xDDFFDE05。

##### 如果 NMT 大于等于 256
后面会是多个 0xDFB4 跟随多个 0xDE** 单元，0xDFB4 的数量比 0xDE** 的数量少 1。

同样用了 Before 的谐音。

0xDE** 可以通过每两位 NMT 加上 0xDE00 得来。如果 NMT 的位数是奇数个，前面补 0。

例如当 NMT=0x125，前面一串就是 0xDDFFDFB4DE01DE25。

进入下一个环节。

将 UCS 码表示成二进制并去掉开头的 0，确保位数是 9 的倍数。如果不是，前面补 0，直到是为止。

然后每九位分割，每段前面填上 1101111，处理后的整串填后面。

以 U+1000000000000000000000000000000000 为例。

NUD=34、NMT=34-23=11。

所以前面是 0xDDFFDE0B。

转成二进制并去掉开头的 0，得 1 0000 0000 0000……

有 133 位，显然不是 9 的倍数。补充并分割。

001000000 000000000 000000000……

补上 1101111。

1101111001000000 1101111000000000 1101111000000000……

所以最终结果是 0xDDFFDE0BDE40DE00DE00DE00DE00DE00DE00DE00DE00DE00DE00DE00DE00DE00DE00。

### UTF-32
#### U+80000000\~U+DFFFFFFF
直接将 UCS 码表示成四字节。

#### U+E0000000\~U+DFFFFFFFFFFFFF
先将 UCS 码表示成七字节。

此时从十六进制看，结构是 aaaaaaabbbbbbb。

然后代入 Faaaaaaa Ebbbbbbb 的结构即可。

如 U+E0000000 表示为 0xF000000EE0000000。

#### U+E0000000000000\~U+FFFFFFFFFFFFFFFFFFF
先将 UCS 码表示成十字节。

此时从十六进制看，结构是 0aaaaabbbbbbbccccccc。

然后代入 FF0aaaaa Ebbbbbbb Eccccccc 的结构即可。

如 U+E0000000000000 表示成 0xFF000000EE000000E0000000。

#### U+10000000000000000000 及以上
重新定义 NMT=NUD-20。

头字节为 0xFF。

注意第一个单元之后的单元都要以 E 开头来引导，所以后面每个单元开头都需要加上 E。

##### 如果 NMT 小于等于 15
那么后接的字节为 0xA0+NMT。

##### 如果 NMT 大于等于 16
首先接上 0xB。0xB 的数量为十六进制下 NMT 位数减一。

B 即是 Before 的首字母。

然后接上一个 0xA。

再之后就只将 NMT 以十六进制写完，操作时一定要注意隔一个单元补 E。

例如 NMT=0x987654321 时，前面的单元是：

0xFFBBBBBB EBBA9876 E54321……

可以看到 E54321 还没有满一个单元（四字节），那么进入下一个环节。

在后面直接将 UCS 码填充下来，如果填充完毕后最后一个单元不足，那么在 UCS 码前面补 0，直到补足为止。

可以进行简易计算。当 UCS 码长度减去上一个环节中最后一单元的剩余十六进制位长度得到的数能被 7 整除，那么这就补足了。

以 U+1000000000000000000000000000000000 为例。

NUD=34、NMT=34-20=14。

所以前面是 0xFFAE。

34-4=30，30 并不是 7 的倍数。所以填充 5 位，变成 U+000001000000000000000000000000000000000。

得到结果：0xFFAE0000E0100000E0000000E0000000E0000000E0000000。

### UTF-1
#### U+80000000 及以上
直接将扩充后的 UTF-32 转成 UTF-1。

### GB 系（GB 18030、UTF-12345）
#### U+110000 及以上
转换成扩充后的 UTF-8，然后在字符的第一字节后面插入字节 0x30。

例如 U+110000 表示成 0xF430908080。

### 屁牌编码
#### U+110000 及以上
直接将扩充后的 UTF-16 转成屁牌编码。

### UTF-EBCDIC 系（UTF-EBCDIC、UTF-8-TR16Mod）
#### U+80000000 及以上
直接将扩充后的 UTF-16 转成 UTF-8-TR16Mod，再处理。
